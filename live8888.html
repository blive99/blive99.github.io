/*
IPTV Web Player (single-file React component)

Features:
- Play HLS (.m3u8) and DASH (.mpd) streams (including AES-128 keyed HLS segments handled by player if playlist references key URI)
- Category menu (Sports, Kids, Movies, Custom)
- Add / edit / delete stream links (saved to localStorage)
- Simple, responsive UI using Tailwind CSS
- Uses hls.js for HLS and dashjs for DASH playback (dynamic imports)

How to run:
1) Create a React app (Vite / Create React App) and install tailwind (or CDN tailwind in index.html). Example with CRA or Vite.
2) Install dependencies: npm install hls.js dashjs
3) Place this file (iptv-player.jsx) and import in your app (e.g., in App.jsx: `import IPTVPlayer from './iptv-player'` and then `<IPTVPlayer/>`).

Notes & limitations
- HLS decryption: if the m3u8 references a KEY URI, hls.js will request it. Make sure the key server has proper CORS headers.
- DASH DRM: advanced DRM (Widevine/PlayReady) requires license servers and EME — this example handles clear DASH and simple setups via dash.js, but not full DRM integration.
- Cross-origin resources (ts segments, keys, mpd) must allow CORS.

*/

import React, { useEffect, useRef, useState } from 'react';
import Hls from 'hls.js';
import dashjs from 'dashjs';

export default function IPTVPlayer() {
  // default sample data
  const DEFAULT_PLAYLISTS = {
    Sports: [
      { id: genId(), name: 'Sample Sports HLS', url: 'https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8' }
    ],
    Kids: [
      { id: genId(), name: 'Sample Kids DASH', url: 'https://dash.akamaized.net/envivio/EnvivioDash3/manifest.mpd' }
    ],
    Movies: [],
    Custom: []
  };

  const [playlists, setPlaylists] = useState(() => loadPlaylists() || DEFAULT_PLAYLISTS);
  const [activeCategory, setActiveCategory] = useState(Object.keys(DEFAULT_PLAYLISTS)[0]);
  const [selected, setSelected] = useState(null);
  const [adding, setAdding] = useState(false);
  const [form, setForm] = useState({ name: '', url: '', category: 'Custom' });

  const videoRef = useRef(null);
  const hlsRef = useRef(null);
  const dashRef = useRef(null);

  useEffect(() => {
    // if selected changed, load it
    if (selected && selected.url) {
      loadStream(selected.url);
    } else {
      unloadPlayers();
    }
    // cleanup on unmount
    return () => unloadPlayers();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selected]);

  function genId() {
    return Math.random().toString(36).slice(2, 9);
  }

  function loadPlaylists() {
    try {
      const raw = localStorage.getItem('iptv_playlists_v1');
      return raw ? JSON.parse(raw) : null;
    } catch (e) {
      return null;
    }
  }

  function savePlaylists(data) {
    localStorage.setItem('iptv_playlists_v1', JSON.stringify(data));
  }

  function unloadPlayers() {
    // destroy hls
    if (hlsRef.current) {
      hlsRef.current.destroy();
      hlsRef.current = null;
    }
    if (dashRef.current) {
      dashRef.current.reset();
      dashRef.current = null;
    }
    const video = videoRef.current;
    if (video) {
      video.pause();
      video.removeAttribute('src');
      video.load();
    }
  }

  async function loadStream(url) {
    const video = videoRef.current;
    if (!video) return;

    unloadPlayers();

    // Treat queryless / missing extension links: try to guess by inspecting url
    const lower = url.split('?')[0].toLowerCase();
    const looksLikeHLS = lower.endsWith('.m3u8') || lower.includes('m3u8');
    const looksLikeDASH = lower.endsWith('.mpd') || lower.includes('mpd');

    if (looksLikeHLS && Hls.isSupported()) {
      const hls = new Hls({
        // optional config: enable AES-128 key handling
        // xhrSetup can be used to add headers if you need (commented example below).
        // xhrSetup: (xhr, url) => { xhr.setRequestHeader('Origin', 'https://yourdomain.com'); }
      });
      hlsRef.current = hls;
      hls.loadSource(url);
      hls.attachMedia(video);
      hls.on(Hls.Events.MANIFEST_PARSED, function () {
        video.play().catch(() => {});
      });
      hls.on(Hls.Events.ERROR, function (event, data) {
        console.error('HLS error', event, data);
      });
    } else if (looksLikeDASH) {
      const player = dashjs.MediaPlayer().create();
      dashRef.current = player;
      player.initialize(video, url, true);
      player.on('error', function (e) { console.error('dash error', e); });
    } else {
      // fallback: set video src directly (browser might play if native)
      video.src = url;
      video.addEventListener('loadedmetadata', () => video.play().catch(() => {}));
    }
  }

  function handleAdd() {
    if (!form.name || !form.url) return alert('กรุณากรอกชื่อและ URL');
    const newItem = { id: genId(), name: form.name, url: form.url };
    const copy = { ...playlists };
    if (!copy[form.category]) copy[form.category] = [];
    copy[form.category] = [newItem, ...copy[form.category]];
    setPlaylists(copy);
    savePlaylists(copy);
    setForm({ name: '', url: '', category: form.category });
    setAdding(false);
  }

  function handleDelete(cat, id) {
    if (!confirm('ลบรายการนี้?')) return;
    const copy = { ...playlists };
    copy[cat] = copy[cat].filter(s => s.id !== id);
    setPlaylists(copy);
    savePlaylists(copy);
    if (selected && selected.id === id) setSelected(null);
  }

  function handleImport() {
    const txt = prompt('วาง JSON playlist ที่จะนำเข้า (รูปแบบ object ของ categories->array)');
    if (!txt) return;
    try {
      const parsed = JSON.parse(txt);
      const merged = { ...playlists, ...parsed };
      setPlaylists(merged);
      savePlaylists(merged);
      alert('นำเข้าเรียบร้อย');
    } catch (e) {
      alert('ไม่สามารถนำเข้า JSON ได้');
    }
  }

  function handleExport() {
    const data = JSON.stringify(playlists, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'iptv_playlists.json';
    a.click();
    URL.revokeObjectURL(url);
  }

  function createCategory() {
    const name = prompt('ชื่อหมวดใหม่');
    if (!name) return;
    if (playlists[name]) return alert('มีหมวดนี้อยู่แล้ว');
    const copy = { ...playlists, [name]: [] };
    setPlaylists(copy);
    savePlaylists(copy);
    setActiveCategory(name);
  }

  return (
    <div className="min-h-screen bg-gray-50 p-4 md:p-8">
      <div className="max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-4 gap-6">
        <aside className="col-span-1 bg-white rounded-2xl shadow p-4">
          <div className="flex items-center justify-between mb-3">
            <h2 className="text-lg font-semibold">เมนูช่อง</h2>
            <div className="flex gap-2">
              <button className="px-2 py-1 rounded-lg border text-sm" onClick={createCategory}>+ หมวด</button>
              <button className="px-2 py-1 rounded-lg border text-sm" onClick={() => { setAdding(true); setForm({ name: '', url: '', category: 'Custom' }); }}>+ ช่อง</button>
            </div>
          </div>

          <div className="space-y-2">
            {Object.keys(playlists).map(cat => (
              <button key={cat} onClick={() => setActiveCategory(cat)} className={`w-full text-left px-3 py-2 rounded-lg ${activeCategory === cat ? 'bg-indigo-600 text-white' : 'hover:bg-gray-100'}`}>
                {cat} <span className="text-xs ml-2">({playlists[cat]?.length || 0})</span>
              </button>
            ))}
          </div>

          <div className="mt-4 text-sm text-gray-600">
            <button className="mr-2" onClick={handleImport}>นำเข้า</button>
            <button onClick={handleExport}>ส่งออก</button>
          </div>
        </aside>

        <main className="md:col-span-3 bg-white rounded-2xl shadow p-4">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div className="md:col-span-2">
              <div className="aspect-video bg-black rounded-lg overflow-hidden">
                <video ref={videoRef} controls playsInline style={{ width: '100%', height: '100%', background: 'black' }} />
              </div>

              <div className="mt-3 flex items-center justify-between">
                <div>
                  <h3 className="font-semibold">{selected ? selected.name : 'ยังไม่ได้เลือกช่อง'}</h3>
                  <div className="text-xs text-gray-500">{selected ? selected.url : ''}</div>
                </div>
                <div>
                  <button className="px-3 py-1 rounded border mr-2" onClick={() => { videoRef.current && videoRef.current.requestFullscreen && videoRef.current.requestFullscreen(); }}>Fullscreen</button>
                  <button className="px-3 py-1 rounded border" onClick={() => { if (videoRef.current) { videoRef.current.pause(); videoRef.current.currentTime = 0; } }}>Stop</button>
                </div>
              </div>

            </div>

            <div>
              <div className="mb-2 flex items-center justify-between">
                <h4 className="font-semibold">รายการใน {activeCategory}</h4>
                <div className="text-sm text-gray-500">คลิกเพื่อเล่น</div>
              </div>

              <div className="space-y-2 max-h-96 overflow-auto pr-2">
                {(playlists[activeCategory] || []).map(item => (
                  <div key={item.id} className={`p-2 rounded-lg flex items-center justify-between ${selected && selected.id === item.id ? 'bg-indigo-50' : 'hover:bg-gray-50'}`}>
                    <div className="flex-1" onClick={() => setSelected(item)} style={{ cursor: 'pointer' }}>
                      <div className="font-medium">{item.name}</div>
                      <div className="text-xs text-gray-500 truncate">{item.url}</div>
                    </div>
                    <div className="flex items-center gap-2 ml-2">
                      <button title="เล่น" onClick={() => setSelected(item)} className="px-2 py-1 border rounded">Play</button>
                      <button title="ลบ" onClick={() => handleDelete(activeCategory, item.id)} className="px-2 py-1 border rounded">Del</button>
                    </div>
                  </div>
                ))}

                {(!playlists[activeCategory] || playlists[activeCategory].length === 0) && (
                  <div className="text-sm text-gray-500">ยังไม่มีช่องในหมวดนี้</div>
                )}
              </div>
            </div>
          </div>

          {/* add form modal */}
          {adding && (
            <div className="fixed inset-0 bg-black/40 flex items-center justify-center">
              <div className="bg-white p-4 rounded-lg w-full max-w-md">
                <h3 className="font-semibold mb-2">เพิ่มช่องใหม่</h3>
                <div className="space-y-2">
                  <input className="w-full p-2 border rounded" placeholder="ชื่อช่อง" value={form.name} onChange={e => setForm({ ...form, name: e.target.value })} />
                  <input className="w-full p-2 border rounded" placeholder="URL (.m3u8 หรือ .mpd)" value={form.url} onChange={e => setForm({ ...form, url: e.target.value })} />
                  <select className="w-full p-2 border rounded" value={form.category} onChange={e => setForm({ ...form, category: e.target.value })}>
                    {Object.keys(playlists).map(k => <option key={k} value={k}>{k}</option>)}
                  </select>
                </div>
                <div className="mt-3 flex justify-end gap-2">
                  <button className="px-3 py-1 border rounded" onClick={() => setAdding(false)}>ยกเลิก</button>
                  <button className="px-3 py-1 bg-indigo-600 text-white rounded" onClick={handleAdd}>บันทึก</button>
                </div>
              </div>
            </div>
          )}

        </main>
      </div>
    </div>
  );
}
